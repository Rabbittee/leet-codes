# Symmetric Tree

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

## Solution

-   DFS

1. 樹如果只有一個節點就可以直接回傳 `true`
2. 把樹切兩半，`l`, `r`
3. 遞迴，每次帶入判斷的兩顆樹，一左一右
    - 當前兩節點是否皆為 `null`，是則回傳 `true` (代表這個節點 "符合" 規則)
    - 當前兩節點其一為 `null`，是則回傳 `false` (代表這個節點 "不符合" 規則)
    - 走到這邊代表，兩節點都不是 null，因此判斷兩者是否等值，否則回傳 false
    - 接著進入遞迴，分別帶入當前兩節點不同方向的下個節點，來達到判斷樹是否鏡射。

-   BFS

1. 樹如果只有一個節點就可以直接回傳 `true`
2. 進入遞迴 (第一次帶入根結點的 left & right 的兩個節點，並建立成一個長度為 2 的陣列)
    1. 宣告兩個索引，為傳入陣列之最左邊與最右邊的 "索引" (l, r)
    2. 宣告兩個新陣列，存入要拿來下一輪處理的陣列
    3. 進入 `while` 迴圈
        - 每一次從頭與尾的值來比較，若不相同代表不是鏡射樹，即回傳 `false`
        - 結束條件 - 如果 `l < r` 代表這個陣列已經全部走完
        1. 遇到左右兩側的值都是 `null` 即跳過，代表是符合題目需求，可以往後面走
        2. 遇到左右兩側的值僅其中一個不是 null，代表不符合需求，直接回傳 `false`
        3. 遇到都有值，則比較是否相同，不相同則回傳 `false`
        4. 接著把目前走的的兩個頭尾的值，分別 `push` 他們的 `left` & `right`，需要注意的是，靠近尾巴那邊的順序要先 `push` `right`
        5. 須注意，如果這時候沒有任何東西被推入陣列，即代表這層沒有東西，回傳 `true` 即可
        6. 把 `right` 反轉並接在 `left` 後面，進入下一次遞迴
